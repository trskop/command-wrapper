# shellcheck shell=bash
# vim: filetype=direnv

# Usage:
#
#   use command_wrapper TOOLSET_NAME CONFIG_DIR
#
# Arguments:
#
#   TOOLSET_NAME
#       Name of the toolset we setting up environment for.
#
#   CONFIG_DIR
#       Project-specific (local environment setup by direnv) configuration
#       directory for Command Wrapper. Directory "${CONFIG_DIR}/${TOOLSET_NAME}"
#       is where the toolset will be looking for its configuration.
#
#       What should be in ${CONFIG_DIR}:
#
#       ${CONFIG_DIR}/
#       ├── config/
#       │   ├── ${toolset}/
#       │   │   ├── default/
#       │   │   │   └── constructor.dhall
#       │   │   └── default.dhall  <<< Will be generated by this function if
#       │   │                          'default/constructor.dhall' exists.
#       │   └── lib/
#       │       ├── CommandWrapper <<< Will be generated by this function.
#       │       ├── Exec           <<< Will be generated by this function.
#       │       ├── Prelude        <<< Will be generated by this function.
#       │       └── *              <<< Local Dhall library used by configs.
#       │                              These are optional.
#       ├── libexec/
#       │   └── ${TOOLSET_NAME}-*  <<< Additional subcommands.  This directory
#       │                              is optional, therefore,
#       │                              'config/${toolset}/default/constructor.dhall'
#       │                              is expected to reference it for it to be
#       │                              used.
#       │
#       └── man/                   <<< Additional manual pages. This directory
#           ├── man1/                  is optional, therefore,
#           │   └── *.1[.gz]           'config/${toolset}/default/constructor.dhall'
#           └── man7/                  is expected to reference it for it to be
#               └── *.7[.gz]           used.
#
#       If you're using version control system then make sure that generated
#       files are ignored.
#
# Example:
#
#    # ...
#    source <(yx direnv --envrc)
#    command_wrapper 'yx' "${PWD}/.command-wrapper'
#    # ...
function use_command_wrapper() {
    if (( ${DEBUG_COMMAND_WRAPPER_DIRENV:-0} )); then
        set -x
        : "${BASH_VERSION}"
    fi

    local DIRENV_LOG_FORMAT="direnv: ${FUNCNAME[0]}: %s"
    if (( ! ${DIRENV_IN_ENVRC:-0} )); then
        # Function log_error may not be available since it is provided by
        # Direnv's stdlib.
        log_error "This function is intended to be evaluated inside '.envrc'." \
        || printf '%s: %s' "${FUNCNAME[0]}" \
            "This function is intended to be evaluated inside '.envrc'." >&2
        return 1
    fi

    local -r toolset="$1"; shift
    local -r config_dir_param="$1"; shift

    if ! command -v "${toolset}" &>/dev/null; then
        log_error "'${toolset}': Not in PATH, has it been installed?"
        return 1
    fi

    # Usage:
    #
    #   toolset [ARGUMENT [...]]
    function toolset() {
        "${toolset}" --no-aliases "$@"
    }

    # Let's make sure that the config dir exists and get an absolute path.
    # This is one of the few ways how to do this reliably on MacOS and Linux.
    local config_dir
    config_dir="$(cd "${config_dir_param}" &>/dev/null && pwd)" || {
        log_error \
            "'${config_dir_param}': Directory does not exist or is not a directory."
        return 1
    }

    # This is where we'll store generated files.  Operations in this directory
    # have to be performed with concurent access in mind.
    local -r cache_dir="${XDG_CACHE_HOME:-${HOME}/.cache}/habit/direnv"
    mkdir -p "${cache_dir}"

    # Usage:
    #
    #   dhall_cache FILE_NAME TARGET_DIR
    #
    # Arguments:
    #
    #   FILE_NAME
    #       Base name of the file that we are creating, i.e. it doesn't contain
    #       any path separators (e.g. slashes).
    #
    #   TARGET_DIR
    #       Where the resulting symbolic link is created.
    function dhall_cache() {
        local -r file_name="$1"; shift
        local -r target_dir="$1"; shift

        # Command `toolset config --dhall-freeze` writes its output atomically,
        # But we need to put content hash into the name of the result, hence
        # the temporary file.
        local file_tmp
        file_tmp="$(
            mktemp "${cache_dir}/${file_name}.tmp.XXXXXXXX"
        )" || {
            log_error 'Unable to create temporary file.'
            return 1
        }

        # Following file reads standard input, i.e. the whole `dhall_cache`
        # reads standard input.
        #
        # Be aware that on some files this may take a while.
        toolset config --dhall-freeze --no-remote-only --for-security \
            --output="${file_tmp}"

        # We hash the content as text to take into account that we may have
        # gotten the content through a different route (file path / URL)
        # even if it normalises to the same content.  Normally it wouldn't
        # be a problem to use Dhall semantic hash of its resulting
        # expression, but if cache gets deleted or if it's explicitly
        # ignored then we may end up trying to import non-existing path.
        file_hash="$(
            toolset config --dhall-hash \
                --expression="${file_tmp} as Text"
        )"
        file_hash="${file_hash#sha256:}"
        file="${cache_dir}/${file_name}-${file_hash}"

        # Both ${file_tmp} and ${file} need to be in the same directory for
        # this operation to be atomic on sensible file systems.
        mv -f "${file_tmp}" "${file}"

        ln -f -s "${file}" "${target_dir}/${file_name}" || {
            log_error \
                "${target_dir}/${file_name}: Failed to create symbolic link."
            return 1
        }
    }

    # {{{ Convenient Imports ##################################################
    #
    # Convenient ways of importyng Command Wrapper Dhall libraries and
    # Dhall Prelude. One way is via environment variable and the second one is
    # via file in "${config_dir}/lib/${lib_name}".
    #
    # Environment variables may have already been exported by e.g. `nix-shell`.
    # In such case they will probably contain absolute path to a file generated
    # when instantiating Command Wrappper toolset derivation.

    declare -A lib_environment_variables=(
        ['COMMAND_WRAPPER_LIB']='command-wrapper:CommandWrapper'
        ['COMMAND_WRAPPER_EXEC_LIB']='exec:Exec'
        ['COMMAND_WRAPPER_PRELUDE_LIB']='prelude:Prelude'
    )

    local lib_import
    local lib_hash
    local lib_name
    local lib_file_name
    local lib_file
    local lib_file_tmp
    mkdir -p "${config_dir}/lib"
    local var
    for var in "${!lib_environment_variables[@]}"; do
        lib_name="${lib_environment_variables[${var}]%%:*}"
        lib_file_name="${lib_environment_variables[${var}]#*:}"
        lib_import="${!var:-}"

        if [[ -z "${lib_import:-}" ]]; then
            lib_import="$(
                toolset completion --library --dhall="${lib_name}" --import
            )"
            export "${var}=${lib_import}"
        fi

        dhall_cache "${lib_file_name}" "${config_dir}/lib" <<< "${lib_import}"
    done

    # }}} Convenient Imports ##################################################

    local toolset_config_dir="${config_dir}/${toolset}"
    local default_config_constructor="${toolset_config_dir}/default/constructor.dhall"
    if [[ -f "${default_config_constructor}" ]]; then
        watch_file "${default_config_constructor}"
        dhall_cache "default.dhall" "${config_dir}/${toolset}" \
            <<< "${default_config_constructor}"
    fi

    export COMMAND_WRAPPER_LOCAL_CONFIG_DIR="${config_dir}"

    # TODO: Extend 'MANPATH' to include Command Wrapper and toolset manaual
    # pages. Be aware that with Nix the MANPATH may overflow.
    #
    # This needs to be after exporting 'COMMAND_WRAPPER_LOCAL_CONFIG_DIR' to
    # include project-specific manual pages.
}
