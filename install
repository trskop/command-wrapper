#!/usr/bin/env stack
{- stack script
    --resolver lts-12.20
    --package directory
    --package executable-path
    --package shake
    --package time
    --
-}

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}

{-# OPTIONS_GHC -Wall #-}

-- |
-- Module:      Main
-- Description: Initialise configuration for applications that do not support
--              XDG Base Directory Specification
-- Copyright:   (c) 2018 Peter TrÅ¡ko
-- License:     BSD3
--
-- Maintainer:  peter.trsko@gmail.com
-- Stability:   experimental
-- Portability: GHC specific language extensions.
--
-- Initialise configuration for applications that do not support XDG Base
-- Directory Specification.
module Main (main)
  where

import Control.Monad (when)
import Data.List (isPrefixOf)
import System.Exit (die)

import Data.Time.Clock.POSIX (getCurrentTime)
import System.Directory
    ( XdgDirectory(XdgConfig)
    , getHomeDirectory
    , getXdgDirectory
    , setCurrentDirectory
    )
import System.Environment.Executable (ScriptPath(..), getScriptPath)

import Development.Shake
--import Development.Shake.Command
import Development.Shake.FilePath
import Development.Shake.Classes (Binary, Hashable, NFData)


newtype ThisGitRepo = ThisGitRepo ()
  deriving (Binary, Eq, Hashable, NFData, Show)

type instance RuleResult ThisGitRepo = String

thisGitRepo :: FilePath -> ThisGitRepo -> Action String
thisGitRepo directory ThisGitRepo{} = do
    Stdout status <- cmd "git status -s -- stack.yaml app/ src/"
    if null @[] @Char status
        then do
            Stdout hash <- cmd "git -C" [directory] "show-ref -s origin/HEAD"
            pure hash
        else
            ("Workspace dirty " <>) . show <$> liftIO getCurrentTime

data Directories = Directories
    { home :: FilePath
    , projectRoot :: FilePath
    , configDir :: FilePath
    , localDir :: FilePath
    }

main :: IO ()
main = do
    projectRoot <- getScriptPath >>= \case
        Executable executable ->
            pure $ takeDirectory executable

        RunGHC script ->
            pure $ takeDirectory script

        Interactive ->
            die "Interactive mode not supported; call shakeMain directly."

    home <- getHomeDirectory
    configDir <- getXdgDirectory XdgConfig ""
    let localDir = home </> ".local"

    setCurrentDirectory projectRoot
    shakeMain Directories{..} shakeOptions

shakeMain :: Directories -> ShakeOptions -> IO ()
shakeMain Directories{..} opts = shakeArgs opts $ do
    let localLibDir = localDir </> "lib"
        localBinDir = localDir </> "bin"

        commandWrapperBin =
            localLibDir </> "command-wrapper" </> "command-wrapper"

    want
        [ commandWrapperBin
        , localBinDir </> "dhall"
        , localBinDir </> "dhall-to-bash"
        , localBinDir </> "dhall-to-json"  -- Implies "dhall-to-yaml".
        , localBinDir </> "dhall-to-text"
        ]

    hasThisRepoChanged <- addOracle (thisGitRepo projectRoot)
    commandWrapperBin %> \out -> do
        _ <- hasThisRepoChanged (ThisGitRepo ())

        let dst = takeDirectory out
        targetExists <- doesDirectoryExist dst
        when targetExists
            $ cmd_ "mkdir -p" [dst]

        cmd_ "stack" ["--local-bin-path=" <> takeDirectory out] "install"

    (localBinDir </> "dhall*") %> \out -> do
        -- TODO: Oracle that checks version.
        let outFile = takeFileName out
            package =
                if "dhall-to-" `isPrefixOf` outFile
                    then "dhall" <> drop 8 outFile
                    else outFile

        cmd_ "stack install" [package]

-- vim:ft=haskell
