-- vim: filetype=dhall

''
#!/usr/bin/env bash

# shellcheck shell=bash

# If you're using Nix then `nix-shell` can be used to call pinned version of
# Bash, and also provide necessary dependencies:
#
#!/usr/bin/env nix-shell
#!nix-shell -i bash
#!nix-shell [--packages PACKAGES|-p PACKAGES|PATH]
#...
#
# Somewhat useful documentation can be found in `nix-shell(1)` documentation
# (https://nixos.org/nix/manual/#sec-nix-shell).

# So called Bash strict mode.  See `bash(1)` documentation  for more details.
set -eo pipefail

if (( BASH_VERSINFO[0] > 4 || ( BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] >= 4 ) )); then
    # Treat unset variables and parameters as an error when expanding.  This
    # wasn't very reliable in older Bash versions, hence the version check.
    set -u

    # Enable the behaviour of 'set -e' inside command substitution.  This
    # option is available since Bash 4.4.
    shopt -s inherit_errexit
fi

if [[ "''${COMMAND_WRAPPER_VERBOSITY:-}" = 'annoying' ]]; then
    # This will cause Bash to print commands before executing them.
    set -x
fi

# Import Command Wrapper Bash library
#
# Environment variables `COMMAND_WRAPPER_NAME` and `COMMAND_WRAPPER_EXE` are
# provided when by Command Wrapper when subcommand is executed.  For more
# information see `command-wrapper-subcommand-protocol(7)` manual page.
#
# shellcheck source=/dev/null
source <(
    COMMAND_WRAPPER_INVOKE_AS="''${COMMAND_WRAPPER_NAME}" "''${COMMAND_WRAPPER_EXE}" \
        completion --library --shell=bash --content
)

# Print help message to standard output.
#
# Usage:
#
#   printHelp
#   printHelp 1>&2
#
# When subcommand is invoked with `-h|--help` option then help information
# needs to be printed to standard output.  If help message is printed as part
# of error message, then it needs to be printed to standard error output.  This
# means that redirection will work the way user expects.  For example:
#
# *   Redirecting help message, e.g. `TOOLSET_COMMAND help SUBCOMMAND | less`
#     will work as expected.
#
# *   Using subcommand in a pipeline.  E.g.
#     `TOOLSET_COMMAND SUBCOMMAND [ARGUMENT [...]] | SOME_COMMAND` will not
#     pass help message as an input to `SOME_COMMAND` if there was an error.
function printHelp() {
    local -r command="''${COMMAND_WRAPPER_NAME} ''${COMMAND_WRAPPER_SUBCOMMAND}"

    # Compose a help command.  If manual page is available then pass '--man'
    # option.
    #
    # Usage:
    #
    #   helpCommand [--man]
    function helpCommand() {
        local -r prefix="''${COMMAND_WRAPPER_NAME} help"

        local opts='''
        if (( $# )); then
            opts="$1"; shift
        fi

        echo "''${prefix} ''${opts:+''${opts} }''${COMMAND_WRAPPER_SUBCOMMAND}"
    }

    # Some command line options that are part of Command Wrapper Subcommand
    # Protocol (`command-wrapper-subcommand-proticol(7)`), like
    # `--completion-info` and `--completion` are considered internal, and
    # should not be presented to the user.
    cat <<EOF
TODO: Hereby I promise to describe this subcommand one day.

Usage:

  ''${command}
  ''${command} {--help|-h}
  $(helpCommand --man)

Options:

  --help, -h
      Print short help message and exit.  Same as: $(helpCommand)
EOF
}

# Print Dhall expression that describes how this subcommand should be invoked
# when performing command line completion.  See
# `command-wrapper-subcommand-protocol(7)` for more details on how this works.
function completionInfo() {
    stdCompletionInfo
}

# Perform command line completion.
#
# Usage:
#
#   completion [--index=INDEX] [--shell=SHELL] [[--] WORD [...]]
#
# Bash itself provides `compgen` builtin command that can do a lot of standard
# command line completion functions.  See `bash(1)` or `help compgen` for more
# details.
function completion() {
    local index=-1
    local -a words=

    local arg
    while (( $# )); do
        arg="$1"; shift
        case "''${arg}" in
            --index=*)
                index="''${arg#*=}"
                ;;
            --shell=*)
                # Ignored.
                ;;
            --)
                words=("$@")
                break
                ;;
            -*)
                die 1 "'%s': Unknown completion option." "''${arg}"
                ;;
            *)
                words=("''${arg}" "$@")
                break
                ;;
        esac
    done

    if (( ! ''${#words[@]} )); then
        words=("")
    fi

    local -r currentWord="''${words[''${index}]}"

    local -i hadDashDash=0
    local -a previousWords=()
    if (( index )); then
        previousWords=("''${words[@]:0:$((index - 1))}")
    fi

    for opt in "''${previousWords[@]}"; do
        if [[ "''${opt}" = '--' ]]; then
            hadDashDash=1
            break
        fi
    done

    local -r -a options=(
        --help -h
    )

    if (( ! hadDashDash )) && [[ "''${currentWord}" == -* ]]; then
        compgen -W "''${options[*]}" -- "''${currentWord}"
    else
        # File completion.
        compgen -f -- "''${currentWord}"
    fi
}

# Read configuration file in Dhall format and declare Bash variables based on
# what's in it.  Subcommand configuration files are required to be in Dhall
# format, however, if you are more comfortable with JSON or YAML then there
# are tools to convert Dhall into them:
#
# * 'dhall-to-json'
# * 'dhall-to-yaml'
#
# Best approach in such case would be to create a temporary file with
# JSON/YAML content that is then used as a configuration file instead.
#
# Note that Subcommands aren't required to use configuration files.  If you
# don't need to use it then delete this function and relevant code in the
# 'main' function.
#
# This function is very simple example of how configuration can be read.  It
# expects configuration file to be a record where individual fields are
# primitive values in Bash sense.  See documentation of Command Wrapper's
# `config` command, specifically `--dhall-bash` functionality.
#
# Usage:
#
#   declareCfg CONFIG_FILE ATTRIBUTE_NAME
#
# Most commonly `CONFIG_FILE` will be `"''${COMMAND_WRAPPER_CONFIG}"`.
function declareCfg() {
    local -r configFile="$1"; shift
    local -r name="$1"; shift

    dhall-to-bash \
        --declare="''${name}" \
        --expression="(''${configFile}).''${name}"
}

# Main entry point.
#
# Usage:
#   main {-h|--help}
#   main --completion-info
#   main --completion [--index=INDEX] [--shell=SHELL] [[--] WORD [...]]
#   main [OPTION [...]] [ARGUMENT [...]]
function main() {
    # This function makes sure that this subcommand was executed using
    # expected calling convention.  If it wasn't it will terminate this
    # script with appropriate error message.  It is hard to guarantee
    # anything in case of it being executed in any other way.  Mentioned
    # calling convention is described in a dedicated manual page:
    #
    #   command-wrapper-subcommand-protocol(7)
    dieIfExecutedOutsideOfCommandWrapperEnvironment

    # It is upto subcommand to decide what command linen options should be
    # supported, and how they should be parsed, but each subcommand has to
    # support following:
    #
    # * --help, -h
    # * --completion-info
    #
    # See Command Wrapper's Subcommand Protocol for more information.  It is
    # available in the form of command-wrapper-subcommand-protocol(7) manual
    # page.
    local arg
    while (( $# )); do
        arg="$1"; shift
        case "''${arg}" in
            # Supporting '--help' is required by the Subcommand Protocol.
            -h|--help)
                # Printing help to standard output and using exit code 0 is
                # required by Subcommand Protocol.
                printHelp
                exit 0
                ;;

            # Supporting '--completion-info' is required by the Subcommand
            # Protocol.
            --completion-info)
                completionInfo
                exit 0
                ;;

            # Implementation of command line completion.  It is up to
            # individual subcommands to decide how this should be implemented,
            # however the implementation of '--completion-info' has to print
            # Dhall expression that is consistent with the chosen approach.
            --completion)
                completion "$@"
                exit 0
                ;;

            # TODO: Define additional options here.
            -*)
                # Using exit code 1 here is required by Subcommand Protocol.
                die 1 "'%s': Unknown option." "''${arg}"
                ;;

            # TODO: Define arguments here.
            *)
                # Using exit code 1 here is required by Subcommand Protocol.
                die 1 "'%s': Too many arguments." "''${arg}"
                ;;
        esac
    done

    # Subcommands aren't required to use configuration files.  If you don't
    # need it then just delete or commend-out config file related code.
    #
    # When subcommand is using configuration file and that doesn't exist it
    # is allowed to do one of the following:
    #
    # 1. Use hardcoded defaults.
    # 2. Fail with error message indicating that the configuration file is
    #    missing.
    #
    # In case of first option subcommand is allowed to generate default
    # configuration file.
    #
    # See command-wrapper-subcommand-protocol(7) manual page for more
    # information.
    if [[ ! -e "''${COMMAND_WRAPPER_CONFIG}" ]]; then
        notice "'%s': Generating default configuration file." \
            "''${COMMAND_WRAPPER_CONFIG}"

        cat > "''${COMMAND_WRAPPER_CONFIG}" <<< '{=}'

        # Alternative would be to use 'dhall format', however, it doesn't
        # preserve comments at the moment.
        #dhall format > "''${COMMAND_WRAPPER_CONFIG}" <<< '{=}'

        # In case of choosing option 2.
        #die 1 "'%s': Configuration file is missing." \
        #    "''${COMMAND_WRAPPER_CONFIG}"
    fi

    out "'%s': Loading configuration file." "''${COMMAND_WRAPPER_CONFIG}"
    eval "$(declareCfg "''${COMMAND_WRAPPER_CONFIG}" 'config')"
    out "'%s': Configuration file loaded." "''${COMMAND_WRAPPER_CONFIG}"

    # TODO: Implement me!  Here is the place where the real functionality
    # should be.
}

main "$@"
''
